/*-----------------------------------------------------------------------
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"; you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-----------------------------------------------------------------------*/
%module(directors="1", "threads"=1) fetpapi
%feature("autodoc", "1");
%feature("python:annotations", "c");
%catches(Swig::DirectorException);

%{
#if defined(__clang__) || defined(_MSC_VER)
#elif defined(__GNUC__) || defined(__GNUG__)
#pragma GCC diagnostic ignored "-Wcast-qual"
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif
%}

#ifdef WITH_FESAPI
%include "${FESAPI_INCLUDE_DIR}/fesapi/nsDefinitions.h"
%import(module="fesapi") "${FESAPI_INCLUDE_DIR}/fesapi/common/DataObjectReference.h"
%import(module="fesapi") "${FESAPI_INCLUDE_DIR}/fesapi/common/HdfProxyFactory.h"
%import(module="fesapi") "${FESAPI_INCLUDE_DIR}/fesapi/common/AbstractObject.h"
#endif

%include "stdint.i"
%include "std_string.i"

%include "../src/nsDefinitions.h"

//************************/
// JAVA
//************************/

#ifdef SWIGJAVA
	// https://stackoverflow.com/a/60208989
	%define PRIMITIVE_TYPEMAP(NEW_TYPE, TYPE)
	%clear NEW_TYPE;
	%apply TYPE { NEW_TYPE };
	%enddef // PRIMITIVE_TYPEMAP
#if defined(SWIGWORDSIZE64)
	PRIMITIVE_TYPEMAP(long int, long long);
	PRIMITIVE_TYPEMAP(unsigned long int, long long);
#endif
	// We don't want to use BigInteger in java.
	PRIMITIVE_TYPEMAP(unsigned long long int, long long);
#undef PRIMITIVE_TYPEMAP
	
	/*
	 When using multiple modules or the nspace feature it is common to invoke SWIG with a different -package command line option for each module.
	 However, by default the generated code may not compile if generated classes in one package use generated classes in another package.
	 The visibility of the getCPtr() and pointer constructor generated from the javabody typemaps needs changing.
	 The default visibility is protected but it needs to be public for access from a different package. Just changing 'protected' to 'public' in the typemap achieves this.
	 Two macros are available in java.swg to make this easier and using them is the preferred approach over simply copying the typemaps and modifying as this is forward compatible with any changes in the javabody typemap in future versions of SWIG.
	 The macros are for the proxy and typewrapper classes and can respectively be used to make the method and constructor public:
	  SWIG_JAVABODY_PROXY(public, public, SWIGTYPE)
	  SWIG_JAVABODY_TYPEWRAPPER(public, public, public, SWIGTYPE)
	*/
	SWIG_JAVABODY_PROXY(public, public, SWIGTYPE)
	SWIG_JAVABODY_TYPEWRAPPER(public, public, public, SWIGTYPE)
	#define SWIG_SHARED_PTR_TYPEMAPS(CONST, TYPE...) SWIG_SHARED_PTR_TYPEMAPS_IMPLEMENTATION(public, public, CONST, TYPE)
	
	// Director threading issues
	%insert("runtime") %{
		#define SWIG_JAVA_ATTACH_CURRENT_THREAD_AS_DAEMON
	%}
	
	// http://www.swig.org/Doc4.0/SWIGDocumentation.html#Java_proper_enums
	%include "enums.swg"
	%javaconst(1);
#endif

//************************/
// CSHARP
//************************/

#ifdef SWIGCSHARP
	SWIG_CSBODY_PROXY(public, public, SWIGTYPE)
	SWIG_CSBODY_TYPEWRAPPER(public, public, public, SWIGTYPE)
#endif

//************************/
// PYTHON
//************************/

#ifdef SWIGPYTHON

	%{
	#define SWIG_FILE_WITH_INIT // In case we use Python Swig Wrapping
	%}

#endif

// Don't try to create vector of polymorphic data unless you really know what you are doing.
// Use C array approach instead.
%include "std_vector.i"

%template(StringVector) std::vector< std::string >;
%template(Int32Vector) std::vector< int32_t >;
%template(UInt32Vector) std::vector< uint32_t >;
// Vector of int64 and uint64 are tough to port because of long vs long long platform
// Indeed c++ long corresponds to int in java where c++ long long corresponds to long in java
%template(FloatVector) std::vector< float >;
%template(DoubleVector) std::vector< double >;
%template(BoolVector) std::vector< bool >;

//************************/
// EXCEPTIONS
//************************/

%include "exception.i"
%exception {
    try {
        $action
    }
    catch (std::invalid_argument & e) {
        SWIG_exception(SWIG_TypeError,const_cast<char*>(e.what()));
    }
    catch (std::out_of_range& e) {
        SWIG_exception(SWIG_IndexError,const_cast<char*>(e.what()));
    }
    catch (std::logic_error & e) {
        SWIG_exception(SWIG_SyntaxError,const_cast<char*>(e.what()));
    }
    catch (std::runtime_error & e) {
        SWIG_exception(SWIG_RuntimeError,const_cast<char*>(e.what()));
    }
    catch(...) {
        SWIG_exception(SWIG_RuntimeError,"Unknown exception at F2I C++ API level");
    }
}

typedef long long 				time_t;

%{
#include "../src/etp/ClientSessionLaunchers.h"
#include "../src/etp/EtpHelpers.h"
%}

#ifdef WITH_FESAPI
%{
#include "../src/etp/fesapi/FesapiHdfProxy.h"
#include "../src/etp/fesapi/FesapiHelpers.h"
%}
#endif

#if defined(SWIGJAVA) || defined(SWIGCSHARP)
	%nspace ETP_NS::ProtocolHandlers;
	%nspace ETP_NS::CoreHandlers;
	%nspace ETP_NS::DiscoveryHandlers;
	%nspace ETP_NS::StoreHandlers;
	%nspace ETP_NS::StoreNotificationHandlers;
	%nspace ETP_NS::DataArrayHandlers;
	%nspace ETP_NS::TransactionHandlers;
	%nspace ETP_NS::DataspaceHandlers;
	%nspace ETP_NS::DataspaceOSDUHandlers;
	%nspace ETP_NS::AbstractSession;
	%nspace ETP_NS::ClientSession;
	%nspace ETP_NS::InitializationParameters;
#ifdef WITH_FESAPI
	%nspace ETP_NS::FesapiHdfProxyFactory;
#endif

	%nspace Energistics::Etp::v12::Datatypes::SupportedDataObject;
	%nspace Energistics::Etp::v12::Datatypes::Uuid;
	%nspace Energistics::Etp::v12::Datatypes::Version;
	%nspace Energistics::Etp::v12::Datatypes::SupportedProtocol;
	%nspace Energistics::Etp::v12::Datatypes::DataValue;
	%nspace Energistics::Etp::v12::Datatypes::DataValueitem_t;
	%nspace Energistics::Etp::v12::Datatypes::ErrorInfo;
	%nspace Energistics::Etp::v12::Datatypes::AnyArrayType;
	%nspace Energistics::Etp::v12::Datatypes::AnyLogicalArrayType;
	%nspace Energistics::Etp::v12::Datatypes::AnyArray;
	%nspace Energistics::Etp::v12::Datatypes::AnyArrayitem_t;
	%nspace Energistics::Etp::v12::Datatypes::ArrayOfBoolean;
	%nspace Energistics::Etp::v12::Datatypes::ArrayOfInt;
	%nspace Energistics::Etp::v12::Datatypes::ArrayOfLong;
	%nspace Energistics::Etp::v12::Datatypes::ArrayOfFloat;
	%nspace Energistics::Etp::v12::Datatypes::ArrayOfDouble;
	%nspace Energistics::Etp::v12::Datatypes::ArrayOfString;
	
	%nspace Energistics::Etp::v12::Datatypes::Object::ActiveStatusKind;
	%nspace Energistics::Etp::v12::Datatypes::Object::ContextInfo;
	%nspace Energistics::Etp::v12::Datatypes::Object::ContextScopeKind;
	%nspace Energistics::Etp::v12::Datatypes::Object::DataObject;
	%nspace Energistics::Etp::v12::Datatypes::Object::Resource;
	%nspace Energistics::Etp::v12::Datatypes::Object::DeletedResource;
	%nspace Energistics::Etp::v12::Datatypes::Object::Dataspace;
	%nspace Energistics::Etp::v12::Datatypes::Object::Edge;
	%nspace Energistics::Etp::v12::Datatypes::Object::RelationshipKind;
	%nspace Energistics::Etp::v12::Datatypes::Object::ObjectChangeKind;
	%nspace Energistics::Etp::v12::Datatypes::Object::ObjectChange;
	%nspace Energistics::Etp::v12::Datatypes::Object::PutResponse;
	%nspace Energistics::Etp::v12::Datatypes::Object::SubscriptionInfo;
	
	
	%nspace Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArrayIdentifier;
	%nspace Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArray;
	%nspace Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArrayMetadata;
	%nspace Energistics::Etp::v12::Datatypes::DataArrayTypes::PutDataArraysType;
	%nspace Energistics::Etp::v12::Datatypes::DataArrayTypes::GetDataSubarraysType;
	%nspace Energistics::Etp::v12::Datatypes::DataArrayTypes::PutDataSubarraysType;
	%nspace Energistics::Etp::v12::Datatypes::DataArrayTypes::PutUninitializedDataArrayType;
	
	%nspace Energistics::Etp::v12::Protocol::Core::OpenSession;
	%nspace Energistics::Etp::v12::Protocol::Core::RequestSession;
	%nspace Energistics::Etp::v12::Protocol::Core::CloseSession;
	%nspace Energistics::Etp::v12::Protocol::Core::ProtocolException;
	%nspace Energistics::Etp::v12::Protocol::Core::Acknowledge;
	%nspace Energistics::Etp::v12::Protocol::Core::Ping;
	%nspace Energistics::Etp::v12::Protocol::Core::Pong;
	%nspace Energistics::Etp::v12::Protocol::Core::Authorize;
	%nspace Energistics::Etp::v12::Protocol::Core::AuthorizeResponse;
	
	%nspace Energistics::Etp::v12::Protocol::Discovery::GetResources;
	%nspace Energistics::Etp::v12::Protocol::Discovery::GetResourcesResponse;
	%nspace Energistics::Etp::v12::Protocol::Discovery::GetResourcesEdgesResponse;
	%nspace Energistics::Etp::v12::Protocol::Discovery::GetDeletedResources;
	%nspace Energistics::Etp::v12::Protocol::Discovery::GetDeletedResourcesResponse;
	
	%nspace Energistics::Etp::v12::Protocol::Store::GetDataObjects;
	%nspace Energistics::Etp::v12::Protocol::Store::GetDataObjectsResponse;
	%nspace Energistics::Etp::v12::Protocol::Store::PutDataObjects;
	%nspace Energistics::Etp::v12::Protocol::Store::PutDataObjectsResponse;
	%nspace Energistics::Etp::v12::Protocol::Store::DeleteDataObjects;
	%nspace Energistics::Etp::v12::Protocol::Store::DeleteDataObjectsResponse;
	%nspace Energistics::Etp::v12::Protocol::Store::Chunk;
	
	%nspace Energistics::Etp::v12::Protocol::DataArray::GetDataArrays;
	%nspace Energistics::Etp::v12::Protocol::DataArray::GetDataArraysResponse;
	%nspace Energistics::Etp::v12::Protocol::DataArray::PutDataArrays;
	%nspace Energistics::Etp::v12::Protocol::DataArray::PutDataArraysResponse;
	%nspace Energistics::Etp::v12::Protocol::DataArray::GetDataSubarrays;
	%nspace Energistics::Etp::v12::Protocol::DataArray::GetDataSubarraysResponse;
	%nspace Energistics::Etp::v12::Protocol::DataArray::PutDataSubarrays;
	%nspace Energistics::Etp::v12::Protocol::DataArray::PutDataSubarraysResponse;
	%nspace Energistics::Etp::v12::Protocol::DataArray::GetDataArrayMetadata;
	%nspace Energistics::Etp::v12::Protocol::DataArray::GetDataArrayMetadataResponse;
	%nspace Energistics::Etp::v12::Protocol::DataArray::PutUninitializedDataArrays;
	%nspace Energistics::Etp::v12::Protocol::DataArray::PutUninitializedDataArraysResponse;
	
	%nspace Energistics::Etp::v12::Protocol::Transaction::StartTransaction;
	%nspace Energistics::Etp::v12::Protocol::Transaction::StartTransactionResponse;
	%nspace Energistics::Etp::v12::Protocol::Transaction::CommitTransaction;
	%nspace Energistics::Etp::v12::Protocol::Transaction::CommitTransactionResponse;
	%nspace Energistics::Etp::v12::Protocol::Transaction::RollbackTransaction;
	%nspace Energistics::Etp::v12::Protocol::Transaction::RollbackTransactionResponse;
	
	%nspace Energistics::Etp::v12::Protocol::Dataspace::GetDataspaces;
	%nspace Energistics::Etp::v12::Protocol::Dataspace::GetDataspacesResponse;
	%nspace Energistics::Etp::v12::Protocol::Dataspace::PutDataspaces;
	%nspace Energistics::Etp::v12::Protocol::Dataspace::PutDataspacesResponse;
	%nspace Energistics::Etp::v12::Protocol::Dataspace::DeleteDataspaces;
	%nspace Energistics::Etp::v12::Protocol::Dataspace::DeleteDataspacesResponse;
	
	%nspace Energistics::Etp::v12::Protocol::DataspaceOSDU::GetDataspaceInfo;
	%nspace Energistics::Etp::v12::Protocol::DataspaceOSDU::GetDataspaceInfoResponse;
	%nspace Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyDataspacesContent;
	%nspace Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyDataspacesContentResponse;
	%nspace Energistics::Etp::v12::Protocol::DataspaceOSDU::LockDataspaces;
	%nspace Energistics::Etp::v12::Protocol::DataspaceOSDU::LockDataspacesResponse;
	%nspace Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyToDataspace;
	%nspace Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyToDataspaceResponse;
	
	%nspace Energistics::Etp::v12::Protocol::StoreNotification::SubscribeNotificationsResponse;
	%nspace Energistics::Etp::v12::Protocol::StoreNotification::Chunk;
	%nspace Energistics::Etp::v12::Protocol::StoreNotification::ObjectAccessRevoked;
	%nspace Energistics::Etp::v12::Protocol::StoreNotification::ObjectDeleted;
	%nspace Energistics::Etp::v12::Protocol::StoreNotification::SubscriptionEnded;
	%nspace Energistics::Etp::v12::Protocol::StoreNotification::UnsubscribeNotifications;
	%nspace Energistics::Etp::v12::Protocol::StoreNotification::ObjectActiveStatusChanged;
	%nspace Energistics::Etp::v12::Protocol::StoreNotification::ObjectChanged;
	%nspace Energistics::Etp::v12::Protocol::StoreNotification::SubscribeNotifications;
	%nspace Energistics::Etp::v12::Protocol::StoreNotification::UnsolicitedStoreNotifications;
#endif

%include "std_map.i"
%template(MapStringString) std::map<std::string, std::string>;

%include "stdint.i"
%include "std_array.i"

%typemap(javaimports) SWIGTYPE %{
	import com.f2i_consulting.fetpapi.*;
%}
				
namespace Energistics {
	namespace Etp {	
		namespace v12 {		
			namespace Datatypes {				
				struct SupportedDataObject{				
					std::string qualifiedType;
					std::map<std::string, Energistics::Etp::v12::Datatypes::DataValue> dataObjectCapabilities;
				};
				
				struct Uuid{				
					std::array<uint8_t, 16> array;
				};
				
				struct Version{				
					int32_t major;
					int32_t minor;
					int32_t revision;
					int32_t patch;
				};
				
				struct SupportedProtocol{				
					int32_t protocol;
					Energistics::Etp::v12::Datatypes::Version protocolVersion;
					std::string role;
				};
				
				struct ArrayOfBoolean{				
					std::vector<bool> values;
				};
				
				struct ArrayOfInt{				
					std::vector<int32_t> values;
				};
				
				struct ArrayOfLong{				
					std::vector<int64_t> values;
				};
				
				struct ArrayOfFloat{				
					std::vector<float> values;
				};
				
				struct ArrayOfDouble{				
					std::vector<double> values;
				};
				
				struct ArrayOfString{				
					std::vector<std::string> values;
				};
				
				struct DataValueitem_t {
				public:				
					size_t idx() const;
					
					bool is_null() const;
					void set_null();
									
					bool get_boolean();				
					void set_boolean(const bool& v);
					
					int32_t get_int();			
					void set_int(const int32_t& v);	
					
					int64_t get_long();				
					void set_long(const int64_t& v);
					
					float get_float();				
					void set_float(const float& v);
					
					double get_double();				
					void set_double(const double& v);
					
					std::string get_string();
					void set_string(const std::string& v);
					
					Energistics::Etp::v12::Datatypes::ArrayOfBoolean get_ArrayOfBoolean();
					void set_ArrayOfBoolean(const Energistics::Etp::v12::Datatypes::ArrayOfBoolean& v);
					
					Energistics::Etp::v12::Datatypes::ArrayOfInt get_ArrayOfInt();
					void set_ArrayOfInt(const Energistics::Etp::v12::Datatypes::ArrayOfInt& v);
					
					Energistics::Etp::v12::Datatypes::ArrayOfLong get_ArrayOfLong();
					void set_ArrayOfLong(const Energistics::Etp::v12::Datatypes::ArrayOfLong& v);
					
					Energistics::Etp::v12::Datatypes::ArrayOfFloat get_ArrayOfFloat();
					void set_ArrayOfFloat(const Energistics::Etp::v12::Datatypes::ArrayOfFloat& v);
					
					Energistics::Etp::v12::Datatypes::ArrayOfDouble get_ArrayOfDouble();
					void set_ArrayOfDouble(const Energistics::Etp::v12::Datatypes::ArrayOfDouble& v);
					
					Energistics::Etp::v12::Datatypes::ArrayOfString get_ArrayOfString();
					void set_ArrayOfString(const Energistics::Etp::v12::Datatypes::ArrayOfString& v);
					
					std::string get_bytes();
					void set_bytes(const std::string& v);
				};
				
				struct DataValue{
					Energistics::Etp::v12::Datatypes::DataValueitem_t item;
				};
				
				struct ErrorInfo{
					std::string message;
					int32_t code;
				};
				
				struct AnyArrayitem_t {
				public:
					size_t idx() const;
					
					Energistics::Etp::v12::Datatypes::ArrayOfBoolean get_ArrayOfBoolean();
					void set_ArrayOfBoolean(const Energistics::Etp::v12::Datatypes::ArrayOfBoolean& v);
					
					Energistics::Etp::v12::Datatypes::ArrayOfInt get_ArrayOfInt();
					void set_ArrayOfInt(const Energistics::Etp::v12::Datatypes::ArrayOfInt& v);
					
					Energistics::Etp::v12::Datatypes::ArrayOfLong get_ArrayOfLong();
					void set_ArrayOfLong(const Energistics::Etp::v12::Datatypes::ArrayOfLong& v);
					
					Energistics::Etp::v12::Datatypes::ArrayOfFloat get_ArrayOfFloat();
					void set_ArrayOfFloat(const Energistics::Etp::v12::Datatypes::ArrayOfFloat& v);
					
					Energistics::Etp::v12::Datatypes::ArrayOfDouble get_ArrayOfDouble();
					void set_ArrayOfDouble(const Energistics::Etp::v12::Datatypes::ArrayOfDouble& v);
					
					Energistics::Etp::v12::Datatypes::ArrayOfString get_ArrayOfString();
					void set_ArrayOfString(const Energistics::Etp::v12::Datatypes::ArrayOfString& v);
					
					std::string get_bytes();
					void set_bytes(const std::string& v);
				};
				
				struct AnyArray{
					Energistics::Etp::v12::Datatypes::AnyArrayitem_t item;
				};	
				
				enum class AnyArrayType {
					arrayOfBoolean=0,
					arrayOfInt=1,
					arrayOfLong=2,
					arrayOfFloat=3,
					arrayOfDouble=4,
					arrayOfString=5,
					bytes=6
				};
				
				enum class AnyLogicalArrayType {
					arrayOfBoolean=0,
					arrayOfInt8=1,
					arrayOfUInt8=2,
					arrayOfInt16LE=3,
					arrayOfInt32LE=4,
					arrayOfInt64LE=5,
					arrayOfUInt16LE=6,
					arrayOfUInt32LE=7,
					arrayOfUInt64LE=8,
					arrayOfFloat32LE=9,
					arrayOfDouble64LE=10,
					arrayOfInt16BE=11,
					arrayOfInt32BE=12,
					arrayOfInt64BE=13,
					arrayOfUInt16BE=14,
					arrayOfUInt32BE=15,
					arrayOfUInt64BE=16,
					arrayOfFloat32BE=17,
					arrayOfDouble64BE=18,
					arrayOfString=19,
					arrayOfCustom=20
				};
			}
		}
	}
}
%template(SupportedDataObjectVector) std::vector<Energistics::Etp::v12::Datatypes::SupportedDataObject>;
%template(uint8_t16Array) std::array<uint8_t, 16>;
%template(SupportedProtocolVector) std::vector<Energistics::Etp::v12::Datatypes::SupportedProtocol>;
%template(MapStringDataValue) std::map<std::string, Energistics::Etp::v12::Datatypes::DataValue>;
%template(MapStringErrorInfo) std::map<std::string, Energistics::Etp::v12::Datatypes::ErrorInfo>;
%template(MapStringArrayOfString) std::map<std::string, Energistics::Etp::v12::Datatypes::ArrayOfString>;

namespace Energistics {
	namespace Etp {
		namespace v12 {
			namespace Datatypes {
				namespace Object {
					enum class ActiveStatusKind : int {
						Active=0,
						Inactive=1
					};
					
					struct ContextInfo{
						std::string uri;
						int32_t depth;
						std::vector<std::string> dataObjectTypes;
					};
					
					enum class ContextScopeKind {
						self=0,
						sources=1,
						targets=2,
						sourcesOrSelf=3,
						targetsOrSelf=4
					};

					struct Resource{
						std::string uri;
						std::vector<std::string> alternateUris;
						std::string name;
						bool has_sourceCount();
						int32_t get_sourceCount();
						bool has_targetCount();
						int32_t get_targetCount();
						int64_t lastChanged;
						int64_t storeLastWrite;
						int64_t storeCreated;
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataValue> customData;
					};
					
					struct DeletedResource{
						std::string uri;
						int64_t deletedTime;
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataValue> customData;
					};

					struct DataObject{
						Energistics::Etp::v12::Datatypes::Object::Resource resource;
						std::string format;
						bool has_blobId();
						Energistics::Etp::v12::Datatypes::Uuid get_blobId();
						std::string data;
					};

					struct Dataspace{
						std::string uri;
						std::string path;
						int64_t storeLastWrite;
						int64_t storeCreated;
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataValue> customData;
					};
					
					struct Edge{
						std::string sourceUri;
						std::string targetUri;
						Energistics::Etp::v12::Datatypes::Object::RelationshipKind relationshipKind;
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataValue> customData;
					};
					
					enum class RelationshipKind {
						Primary=0,
						Secondary=1,
						Both=2
					};
					
					enum class ObjectChangeKind : int {
						insert=0,
						update=1,
						authorized=2,
						joined=3,
						unjoined=4,
						joinedSubscription=5,
						unjoinedSubscription=6
					};

					struct ObjectChange{
						Energistics::Etp::v12::Datatypes::Object::ObjectChangeKind changeKind;
						int64_t changeTime;
						Energistics::Etp::v12::Datatypes::Object::DataObject dataObject;
					};

					struct PutResponse{					
						std::vector<std::string> createdContainedObjectUris;
						std::vector<std::string> deletedContainedObjectUris;
						std::vector<std::string> joinedContainedObjectUris;
						std::vector<std::string> unjoinedContainedObjectUris;
					};

					struct SubscriptionInfo{					
						Energistics::Etp::v12::Datatypes::Object::ContextInfo context;
						Energistics::Etp::v12::Datatypes::Object::ContextScopeKind scope;
						Energistics::Etp::v12::Datatypes::Uuid requestUuid;
						bool includeObjectData=false;
						std::string format;
					};
				}
			}
		}
	}
}
%template(ResourceVector) std::vector<Energistics::Etp::v12::Datatypes::Object::Resource>;
%template(DeletedResourceVector) std::vector<Energistics::Etp::v12::Datatypes::Object::DeletedResource>;
%template(DataspaceVector) std::vector<Energistics::Etp::v12::Datatypes::Object::Dataspace>;
%template(EdgeVector) std::vector<Energistics::Etp::v12::Datatypes::Object::Edge>;
%template(MapStringDataObject) std::map<std::string, Energistics::Etp::v12::Datatypes::Object::DataObject>;
%template(MapStringDataspace) std::map<std::string, Energistics::Etp::v12::Datatypes::Object::Dataspace>;
%template(MapStringPutResponse) std::map<std::string, Energistics::Etp::v12::Datatypes::Object::PutResponse>;
%template(MapStringSubscriptionInfo) std::map<std::string, Energistics::Etp::v12::Datatypes::Object::SubscriptionInfo>;
%template(SubscriptionInfoVector) std::vector<Energistics::Etp::v12::Datatypes::Object::SubscriptionInfo>;

namespace Energistics {
	namespace Etp {	
		namespace v12 {		
			namespace Datatypes {			
				namespace DataArrayTypes {			
					struct DataArrayIdentifier{					
						std::string uri;
						std::string pathInResource;
					};		
					
					struct DataArray{					
						std::vector<int64_t> dimensions;
						Energistics::Etp::v12::Datatypes::AnyArray data;
					};

					struct DataArrayMetadata{					
						std::vector<int64_t> dimensions;
						std::vector<int64_t> preferredSubarrayDimensions;
						Energistics::Etp::v12::Datatypes::AnyArrayType transportArrayType;
						Energistics::Etp::v12::Datatypes::AnyLogicalArrayType logicalArrayType;
						int64_t storeLastWrite;
						int64_t storeCreated;
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataValue> customData;
					};

					struct PutDataArraysType{
						Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArrayIdentifier uid;
						Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArray array;
					};

					struct GetDataSubarraysType{					
						Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArrayIdentifier uid;
						std::vector<int64_t> starts;
						std::vector<int64_t> counts;
					};

					struct PutDataSubarraysType{					
						Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArrayIdentifier uid;
						Energistics::Etp::v12::Datatypes::AnyArray data;
						std::vector<int64_t> starts;
						std::vector<int64_t> counts;
					};

					struct PutUninitializedDataArrayType{					
						Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArrayIdentifier uid;
						Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArrayMetadata metadata;
					};					
				}
			}
		}
	}
}
%template(MapStringDataArrayIdentifier) std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArrayIdentifier>;
%template(MapStringDataArray) std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArray>;
%template(MapStringDataArrayMetadata) std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArrayMetadata>;
%template(MapStringPutDataArraysType) std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::PutDataArraysType>;
%template(MapStringGetDataSubarraysType) std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::GetDataSubarraysType>;
%template(MapStringPutDataSubarraysType) std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::PutDataSubarraysType>;
%template(MapStringPutUninitializedDataArrayType) std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::PutUninitializedDataArrayType>;

/**************** CORE PROTOCOL  *****************/

namespace Energistics {
	namespace Etp {	
		namespace v12 {		
			namespace Protocol {			
				namespace Core {				
					struct RequestSession{					
						std::string applicationName;
						std::string applicationVersion;
						Energistics::Etp::v12::Datatypes::Uuid clientInstanceId;
						std::vector<Energistics::Etp::v12::Datatypes::SupportedProtocol> requestedProtocols;
						std::vector<Energistics::Etp::v12::Datatypes::SupportedDataObject> supportedDataObjects;
						std::vector<std::string> supportedCompression;
						std::vector<std::string> supportedFormats;
						int64_t currentDateTime;
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataValue> endpointCapabilities;
						static const int messageTypeId=1;
					};
					
					struct OpenSession{					
						std::string applicationName;
						std::string applicationVersion;
						Energistics::Etp::v12::Datatypes::Uuid serverInstanceId;
						std::vector<Energistics::Etp::v12::Datatypes::SupportedProtocol> supportedProtocols;
						std::vector<Energistics::Etp::v12::Datatypes::SupportedDataObject> supportedDataObjects;
						std::string supportedCompression;
						std::vector<std::string> supportedFormats;
						Energistics::Etp::v12::Datatypes::Uuid sessionId;
						int64_t currentDateTime;
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataValue> endpointCapabilities;
						static const int messageTypeId=2;
					};
					
					struct CloseSession{					
						std::string reason;
						static const int messageTypeId=5;
					};
					
					struct Authorize{
						std::string authorization;
						std::map<std::string, std::string> supplementalAuthorization;
						static const int messageTypeId=6;
					};
					
					struct AuthorizeResponse{
						bool success=false;
						std::vector<std::string> challenges;
						static const int messageTypeId=7;
					};
					
					struct Ping{					
						int64_t currentDateTime;
						static const int messageTypeId=8;
					};
					
					struct Pong{					
						int64_t currentDateTime;
						static const int messageTypeId=9;
					};
					
					struct ProtocolException{
						bool has_error();
						Energistics::Etp::v12::Datatypes::ErrorInfo get_error();
						std::map<std::string, Energistics::Etp::v12::Datatypes::ErrorInfo> errors;
						static const int messageTypeId=1000;
					};
					
					struct Acknowledge{					
						static const int messageTypeId=1001;
						int protocolId;
					};
				}
			}
		}
	}
}

/**************** DISCOVERY PROTOCOL  *****************/

namespace Energistics {
	namespace Etp {	
		namespace v12 {		
			namespace Protocol {			
				namespace Discovery {				
					struct GetResources{					
						Energistics::Etp::v12::Datatypes::Object::ContextInfo context;
						Energistics::Etp::v12::Datatypes::Object::ContextScopeKind scope;
						bool countObjects=false;
						bool has_storeLastWriteFilter();
						int64_t get_storeLastWriteFilter();
						bool has_activeStatusFilter();
						Energistics::Etp::v12::Datatypes::Object::ActiveStatusKind get_activeStatusFilter();
						static const int messageTypeId=1;
					};
					
					struct GetResourcesResponse{					
						std::vector<Energistics::Etp::v12::Datatypes::Object::Resource> resources;
						static const int messageTypeId=4;
					};
					
					struct GetDeletedResources{
						std::string dataspaceUri;
						bool has_deleteTimeFilter();
						int64_t get_deleteTimeFilter();
						std::vector<std::string> dataObjectTypes;
						static const int messageTypeId=5;
					};
					
					struct GetDeletedResourcesResponse{					
						std::vector<Energistics::Etp::v12::Datatypes::Object::DeletedResource> deletedResources;
						static const int messageTypeId=6;
					};
					
					struct GetResourcesEdgesResponse{					
						std::vector<Energistics::Etp::v12::Datatypes::Object::Edge> edges;
						static const int messageTypeId=7;
					};
				}
			}
		}
	}
}

/**************** STORE PROTOCOL  *****************/

namespace Energistics {
	namespace Etp {	
		namespace v12 {		
			namespace Protocol {			
				namespace Store {				
					struct GetDataObjects{					
						std::map<std::string, std::string> uris;
						std::string format;
						static const int messageTypeId=1;
					};
					
					struct PutDataObjects{					
						std::map<std::string, Energistics::Etp::v12::Datatypes::Object::DataObject> dataObjects;
						bool pruneContainedObjects=false;
						static const int messageTypeId=2;
					};
					
					struct DeleteDataObjects{					
						std::map<std::string, std::string> uris;
						bool pruneContainedObjects=false;
						static const int messageTypeId=3;
					};
					
					struct GetDataObjectsResponse{					
						std::map<std::string, Energistics::Etp::v12::Datatypes::Object::DataObject> dataObjects;
						static const int messageTypeId=4;
					};
					
#if defined(SWIGPYTHON)
					%rename(Store_Chunk) Chunk;
#endif
					struct Chunk{					
						Energistics::Etp::v12::Datatypes::Uuid blobId;
						std::string data;
						bool final=false;
						static const int messageTypeId=8;
					};
					
					struct PutDataObjectsResponse{					
						std::map<std::string, Energistics::Etp::v12::Datatypes::Object::PutResponse> success;
						static const int messageTypeId=9;
					};
					
					struct DeleteDataObjectsResponse{					
						std::map<std::string, Energistics::Etp::v12::Datatypes::ArrayOfString> deletedUris;
						static const int messageTypeId=10;
					};
				}
			}
		}
	}
}

/**************** DATA ARRAY PROTOCOL  *****************/

namespace Energistics {
	namespace Etp {	
		namespace v12 {		
			namespace Protocol {			
				namespace DataArray {				
					struct GetDataArrays{					
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArrayIdentifier> dataArrays;
						static const int messageTypeId=2;
					};
					
					struct GetDataArraysResponse{					
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArray> dataArrays;
						static const int messageTypeId=1;
					};
					
					struct GetDataSubarrays{					
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::GetDataSubarraysType> dataSubarrays;
						static const int messageTypeId=3;
					};
					
					struct GetDataSubarraysResponse{					
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArray> dataSubarrays;
						static const int messageTypeId=8;
					};
					
					struct PutDataArrays{					
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::PutDataArraysType> dataArrays;
						static const int messageTypeId=4;
					};
					
					struct PutDataArraysResponse{					
						std::map<std::string, std::string> success;
						static const int messageTypeId=10;
					};
					
					struct PutDataSubarrays{					
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::PutDataSubarraysType> dataSubarrays;
						static const int messageTypeId=5;
					};
					
					struct PutDataSubarraysResponse{					
						std::map<std::string, std::string> success;
						static const int messageTypeId=11;
					};
					
					struct PutUninitializedDataArrays{					
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::PutUninitializedDataArrayType> dataArrays;
						static const int messageTypeId=9;
					};
					
					struct PutUninitializedDataArraysResponse{					
						std::map<std::string, std::string> success;
						static const int messageTypeId=12;
					};
					
					struct GetDataArrayMetadata{					
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArrayIdentifier> dataArrays;
						static const int messageTypeId=6;
					};
					
					struct GetDataArrayMetadataResponse{					
						std::map<std::string, Energistics::Etp::v12::Datatypes::DataArrayTypes::DataArrayMetadata> arrayMetadata;
						static const int messageTypeId=7;
					};
				}
			}
		}
	}
}

/**************** TRANSACTION PROTOCOL  *****************/

namespace Energistics {
	namespace Etp {	
		namespace v12 {		
			namespace Protocol {			
				namespace Transaction {				
					struct StartTransaction{					
						bool readOnly=false;
						std::string message;
						std::vector<std::string> dataspaceUris;
						static const int messageTypeId=1;
					};
					
					struct StartTransactionResponse{					
						Energistics::Etp::v12::Datatypes::Uuid transactionUuid;
						bool successful=false;
						std::string failureReason;
						static const int messageTypeId=2;
					};
					
					struct CommitTransaction{					
						Energistics::Etp::v12::Datatypes::Uuid transactionUuid;
						static const int messageTypeId=3;
					};
					
					struct RollbackTransaction{					
						Energistics::Etp::v12::Datatypes::Uuid transactionUuid;
						static const int messageTypeId=4;
					};
					
					struct CommitTransactionResponse{					
						Energistics::Etp::v12::Datatypes::Uuid transactionUuid;
						bool successful=false;
						std::string failureReason;
						static const int messageTypeId=5;
					};
					
					struct RollbackTransactionResponse{					
						Energistics::Etp::v12::Datatypes::Uuid transactionUuid;
						bool successful=false;
						std::string failureReason;
						static const int messageTypeId=6;
					};
				}
			}
		}
	}
}

/**************** DATASPACE PROTOCOL  *****************/

namespace Energistics {
	namespace Etp {
		namespace v12 {
			namespace Protocol {
				namespace Dataspace {
					struct GetDataspaces{
						bool has_storeLastWriteFilter();
						int64_t get_storeLastWriteFilter();
						static const int messageTypeId=1;
					};
					
					struct GetDataspacesResponse{					
						std::vector<Energistics::Etp::v12::Datatypes::Object::Dataspace> dataspaces;
						static const int messageTypeId=2;
					};
					
					struct PutDataspaces{					
						std::map<std::string, Energistics::Etp::v12::Datatypes::Object::Dataspace> dataspaces;
						static const int messageTypeId=3;
					};
					
					struct PutDataspacesResponse{					
						std::map<std::string, std::string> success;
						static const int messageTypeId=6;
					};
					
					struct DeleteDataspaces{					
						std::map<std::string, std::string> uris;
						static const int messageTypeId=4;
					};
					
					struct DeleteDataspacesResponse{					
						std::map<std::string, std::string> success;
						static const int messageTypeId=5;
					};
				}
			}
		}
	}
}

/**************** DATASPACE OSDU PROTOCOL  *****************/

namespace Energistics {
	namespace Etp {
		namespace v12 {
			namespace Protocol {
				namespace DataspaceOSDU {
					struct GetDataspaceInfo {
						std::map<std::string, std::string> uris;
						static constexpr int messageTypeId = 1;
					};
					
					struct GetDataspaceInfoResponse {
						std::map<std::string, Energistics::Etp::v12::Datatypes::Object::Dataspace> dataspaces;
						static constexpr int messageTypeId = 2;
					};
					
					struct CopyDataspacesContent {
						std::map<std::string, std::string> dataspaces;
						std::string targetDataspace;
						static constexpr int messageTypeId = 3;
					};
					
					struct CopyDataspacesContentResponse {
						std::map<std::string, std::string> success;
						static constexpr int messageTypeId = 4;
					};
					
					struct LockDataspaces {
						std::map<std::string, std::string> uris;
						bool lock;
						static constexpr int messageTypeId = 5;
					};
					
					struct LockDataspacesResponse {
						std::map<std::string, std::string> success;
						static constexpr int messageTypeId = 6;
					};
					
					struct CopyToDataspace {
						std::map<std::string, std::string> uris;
						std::string dataspaceUri;
						static constexpr int messageTypeId = 7;
					};
					
					struct CopyToDataspaceResponse {
						std::map<std::string, std::string> success;
						static constexpr int messageTypeId = 8;
					};
				}
			}
		}
	}
}

/**************** STORE NOTIFICATION PROTOCOL  *****************/

namespace Energistics {
	namespace Etp {
		namespace v12 {
			namespace Protocol {
				namespace StoreNotification {
					struct SubscribeNotificationsResponse{
						std::map<std::string, std::string> success;
						static const int messageTypeId=10;
					};
					
#if defined(SWIGPYTHON)
					%rename(StoreNotification_Chunk) Chunk;
#endif
					struct Chunk{
						Energistics::Etp::v12::Datatypes::Uuid blobId;
						std::string data;
						bool final=false;
						static const int messageTypeId=9;
					};
					struct ObjectAccessRevoked{
						std::string uri;
						int64_t changeTime;
						Energistics::Etp::v12::Datatypes::Uuid requestUuid;
						static const int messageTypeId=5;
					};
					struct ObjectDeleted{
						std::string uri;
						int64_t changeTime;
						Energistics::Etp::v12::Datatypes::Uuid requestUuid;
						static const int messageTypeId=3;
					};
					struct SubscriptionEnded{
						std::string reason;
						Energistics::Etp::v12::Datatypes::Uuid requestUuid;
						static const int messageTypeId=7;
					};
					struct UnsubscribeNotifications{
						Energistics::Etp::v12::Datatypes::Uuid requestUuid;
						static const int messageTypeId=4;
					};
					struct ObjectActiveStatusChanged{
						Energistics::Etp::v12::Datatypes::Object::ActiveStatusKind activeStatus;
						int64_t changeTime;
						Energistics::Etp::v12::Datatypes::Object::Resource resource;
						Energistics::Etp::v12::Datatypes::Uuid requestUuid;
						static const int messageTypeId=11;
					};
					struct ObjectChanged{
						Energistics::Etp::v12::Datatypes::Object::ObjectChange change;
						Energistics::Etp::v12::Datatypes::Uuid requestUuid;
						static const int messageTypeId=2;
					};
					struct SubscribeNotifications{
						std::map<std::string, Energistics::Etp::v12::Datatypes::Object::SubscriptionInfo> request;
						static const int messageTypeId=6;
					};
					struct UnsolicitedStoreNotifications{
						std::vector<Energistics::Etp::v12::Datatypes::Object::SubscriptionInfo> subscriptions;
						static const int messageTypeId=8;
					};
				}
			}
		}
	}
}

%include <std_shared_ptr.i>
%shared_ptr(ETP_NS::ProtocolHandlers)
%shared_ptr(ETP_NS::CoreHandlers)
%shared_ptr(ETP_NS::DiscoveryHandlers)
%shared_ptr(ETP_NS::StoreHandlers)
%shared_ptr(ETP_NS::StoreNotificationHandlers)
%shared_ptr(ETP_NS::DataArrayHandlers)
%shared_ptr(ETP_NS::TransactionHandlers)
%shared_ptr(ETP_NS::DataspaceHandlers)
%shared_ptr(ETP_NS::DataspaceOSDUHandlers)
%shared_ptr(ETP_NS::AbstractSession)
%shared_ptr(ETP_NS::ClientSession)

%feature("director") ETP_NS::CoreHandlers;
%feature("director") ETP_NS::DiscoveryHandlers;
%feature("director") ETP_NS::StoreHandlers;
%feature("director") ETP_NS::StoreNotificationHandlers;
%feature("director") ETP_NS::DataArrayHandlers;
%feature("director") ETP_NS::TransactionHandlers;
%feature("director") ETP_NS::DataspaceHandlers;
%feature("director") ETP_NS::DataspaceOSDUHandlers;
%feature("director") ETP_NS::InitializationParameters;

/* Following extensions aims at preventing the Python garbage collector from 
   garbage collecting a protocol handler that may be still used by a session. */
#ifdef SWIGPYTHON
	%fragment("core_handler_reference_init", "init") {
		core_handler_reference();
	}
	%fragment("core_handler_reference_function", "header", fragment="core_handler_reference_init") {
		static PyObject *core_handler_reference() {
		  static PyObject *core_handler_reference_string = SWIG_Python_str_FromChar("__core_handler_reference");
		  return core_handler_reference_string;
		}
	}
	%extend ETP_NS::AbstractSession {
		%typemap(ret, fragment="core_handler_reference_function") void setCoreProtocolHandlers(std::shared_ptr<ETP_NS::CoreHandlers> coreHandlers) %{
		  PyObject_SetAttr($self, core_handler_reference(), args);
		%}
	}
	
	%fragment("discovery_handler_reference_init", "init") {
		discovery_handler_reference();
	}
	%fragment("discovery_handler_reference_function", "header", fragment="discovery_handler_reference_init") {
		static PyObject *discovery_handler_reference() {
		  static PyObject *discovery_handler_reference_string = SWIG_Python_str_FromChar("__discovery_handler_reference");
		  return discovery_handler_reference_string;
		}
	}
	%extend ETP_NS::AbstractSession {
		%typemap(ret, fragment="discovery_handler_reference_function") void setDiscoveryProtocolHandlers(std::shared_ptr<DiscoveryHandlers> discoveryHandlers) %{
		  PyObject_SetAttr($self, discovery_handler_reference(), args);
		%}
	}
	
	%fragment("store_handler_reference_init", "init") {
	  store_handler_reference();
	}

	%fragment("store_handler_reference_function", "header", fragment="store_handler_reference_init") {
		static PyObject *store_handler_reference() {
		  static PyObject *store_handler_reference_string = SWIG_Python_str_FromChar("__store_handler_reference");
		  return store_handler_reference_string;
		}
	}

	%extend ETP_NS::AbstractSession {
		%typemap(ret, fragment="store_handler_reference_function") void setStoreProtocolHandlers(std::shared_ptr<StoreHandlers> storeHandlers) %{
		  PyObject_SetAttr($self, store_handler_reference(), args);
		%}
	}
	
	%fragment("store_notification_handler_reference_init", "init") {
		store_notification_handler_reference();
	}

	%fragment("store_notification_handler_reference_function", "header", fragment="store_notification_handler_reference_init") {
		static PyObject *store_notification_handler_reference() {
			static PyObject *store_notification_handler_reference_string = SWIG_Python_str_FromChar("__store_notification_handler_reference");
			return store_notification_handler_reference_string;
		}
	}

	%extend ETP_NS::AbstractSession {
		%typemap(ret, fragment="store_notification_handler_reference_function") void setStoreNotificationProtocolHandlers(std::shared_ptr<ETP_NS::StoreNotificationHandlers> storeNotificationHandlers) %{
		  PyObject_SetAttr($self, store_notification_handler_reference(), args);
		%}
	}

	// DataArray	
	%fragment("data_array_handler_reference_init", "init") {
	  data_array_handler_reference();
	}

	%fragment("data_array_handler_reference_function", "header", fragment="data_array_handler_reference_init") {

	static PyObject *data_array_handler_reference() {
		static PyObject *data_array_handler_reference_string = SWIG_Python_str_FromChar("__data_array_handler_reference");
		return data_array_handler_reference_string;
		}
	}

	%extend ETP_NS::AbstractSession {
		%typemap(ret, fragment="data_array_handler_reference_function") void setDataArrayProtocolHandlers(std::shared_ptr<DataArrayHandlers> dataArrayHandlers) %{
			PyObject_SetAttr($self, data_array_handler_reference(), args);
		%}
	}
	
	// Transaction	
	%fragment("transaction_handler_reference_init", "init") {
		  transaction_handler_reference();
	}
	%fragment("transaction_handler_reference_function", "header", fragment="transaction_handler_reference_init") {
		static PyObject *transaction_handler_reference() {
		  static PyObject *transaction_handler_reference_string = SWIG_Python_str_FromChar("__transaction_handler_reference");
		  return transaction_handler_reference_string;
		}
	}

	%extend ETP_NS::AbstractSession {
		%typemap(ret, fragment="transaction_handler_reference_function") void setTransactionProtocolHandlers(std::shared_ptr<TransactionHandlers> transactionHandlers) %{
			  PyObject_SetAttr($self, transaction_handler_reference(), args);
			%}
	}
	
	// Dataspace
	%fragment("dataspace_handler_reference_init", "init") {
		  dataspace_handler_reference();
	}
	%fragment("dataspace_handler_reference_function", "header", fragment="dataspace_handler_reference_init") {
		static PyObject *dataspace_handler_reference() {
		  static PyObject *dataspace_handler_reference_string = SWIG_Python_str_FromChar("__dataspace_handler_reference");
		  return dataspace_handler_reference_string;
		}
	}

	%extend ETP_NS::AbstractSession {
	%typemap(ret, fragment="dataspace_handler_reference_function") void setDataspaceProtocolHandlers(std::shared_ptr<DataspaceHandlers> dataspaceHandlers) %{
		  PyObject_SetAttr($self, dataspace_handler_reference(), args);
		%}
	}
	
	// Dataspace OSDU
	%fragment("dataspace_osdu_handler_reference_init", "init") {
		  dataspace_osdu_handler_reference();
	}
	%fragment("dataspace_osdu_handler_reference_function", "header", fragment="dataspace_osdu_handler_reference_init") {
		static PyObject *dataspace_osdu_handler_reference() {
		  static PyObject *dataspace_osdu_handler_reference_string = SWIG_Python_str_FromChar("__dataspace_osdu_handler_reference");
		  return dataspace_osdu_handler_reference_string;
		}
	}

	%extend ETP_NS::AbstractSession {
	%typemap(ret, fragment="dataspace_osdu_handler_reference_function") void setDataspaceOSDUProtocolHandlers(std::shared_ptr<DataspaceOSDUHandlers> dataspaceOSDUHandlers) %{
		  PyObject_SetAttr($self, dataspace_osdu_handler_reference(), args);
		%}
	}
#endif 
	
#ifdef SWIGCSHARP
%typemap(cscode) ETP_NS::AbstractSession %{
  private CoreHandlers coreHandlersReference = null;
  private DiscoveryHandlers discoveryHandlersReference = null;
  private StoreHandlers storeHandlersReference = null;
  private StoreNotificationHandlers storeNotificationHandlersReference = null;
  private DataArrayHandlers dataArrayHandlersReference = null;
  private TransactionHandlers transactionHandlersReference = null;
  private DataspaceHandlers dataspaceHandlersReference = null;
  private DataspaceOSDUHandlers dataspaceOSDUHandlersReference = null;
%}

%typemap(csin,
         post="      coreHandlersReference = $csinput;"
         ) std::shared_ptr<ETP_NS::CoreHandlers> coreHandlers "CoreHandlers.getCPtr($csinput)"

%typemap(csin,
         post="      discoveryHandlersReference = $csinput;"
         ) std::shared_ptr<ETP_NS::DiscoveryHandlers> discoveryHandlers "DiscoveryHandlers.getCPtr($csinput)"

%typemap(csin,
         post="      storeHandlersReference = $csinput;"
         ) std::shared_ptr<ETP_NS::StoreHandlers> storeHandlers "StoreHandlers.getCPtr($csinput)"

%typemap(csin,
         post="      storeNotificationHandlersReference = $csinput;"
         ) std::shared_ptr<ETP_NS::StoreNotificationHandlers> storeNotificationHandlers "StoreNotificationHandlers.getCPtr($csinput)"

%typemap(csin,
         post="      dataArrayHandlersReference = $csinput;"
         ) std::shared_ptr<ETP_NS::DataArrayHandlers> dataArrayHandlers "DataArrayHandlers.getCPtr($csinput)"

%typemap(csin,
         post="      transactionHandlersReference = $csinput;"
         ) std::shared_ptr<ETP_NS::TransactionHandlers> transactionHandlers "TransactionHandlers.getCPtr($csinput)"

%typemap(csin,
         post="      dataspaceHandlersReference = $csinput;"
         ) std::shared_ptr<ETP_NS::DataspaceHandlers> dataspaceHandlers "DataspaceHandlers.getCPtr($csinput)"

%typemap(csin,
         post="      dataspaceOSDUHandlersReference = $csinput;"
         ) std::shared_ptr<ETP_NS::DataspaceOSDUHandlers> dataspaceOSDUHandlers "DataspaceOSDUHandlers.getCPtr($csinput)"
#endif

#ifdef SWIGJAVA
%typemap(javacode) ETP_NS::AbstractSession %{
  private CoreHandlers coreHandlersReference;
  private DiscoveryHandlers discoveryHandlersReference;
  private StoreHandlers storeHandlersReference;
  private StoreNotificationHandlers storeNotificationHandlersReference;
  private DataArrayHandlers dataArrayHandlersReference;
  private TransactionHandlers transactionHandlersReference;
  private DataspaceHandlers dataspaceHandlersReference;
  private DataspaceOSDUHandlers dataspaceOSDUHandlersReference;
%}

%typemap(javain, 
         post="      coreHandlersReference = $javainput;"
         ) std::shared_ptr<ETP_NS::CoreHandlers> coreHandlers "CoreHandlers.getCPtr($javainput)"

%typemap(javain, 
         post="      discoveryHandlersReference = $javainput;"
         ) std::shared_ptr<ETP_NS::DiscoveryHandlers> discoveryHandlers "DiscoveryHandlers.getCPtr($javainput)"

%typemap(javain, 
         post="      storeHandlersReference = $javainput;"
         ) std::shared_ptr<ETP_NS::StoreHandlers> storeHandlers "StoreHandlers.getCPtr($javainput)"

%typemap(javain, 
         post="      storeNotificationHandlersReference = $javainput;"
         ) std::shared_ptr<ETP_NS::StoreNotificationHandlers> storeNotificationHandlers "StoreNotificationHandlers.getCPtr($javainput)"

%typemap(javain, 
         post="      dataArrayHandlersReference = $javainput;"
         ) std::shared_ptr<ETP_NS::DataArrayHandlers> dataArrayHandlers "DataArrayHandlers.getCPtr($javainput)"

%typemap(javain,
         post="      transactionHandlersReference = $javainput;"
         ) std::shared_ptr<ETP_NS::TransactionHandlers> transactionHandlers "TransactionHandlers.getCPtr($javainput)"

%typemap(javain, 
         post="      dataspaceHandlersReference = $javainput;"
         ) std::shared_ptr<ETP_NS::DataspaceHandlers> dataspaceHandlers "DataspaceHandlers.getCPtr($javainput)"

%typemap(javain, 
         post="      dataspaceOSDUHandlersReference = $javainput;"
         ) std::shared_ptr<ETP_NS::DataspaceOSDUHandlers> dataspaceOSDUHandlers "DataspaceOSDUHandlers.getCPtr($javainput)"
#endif

namespace ETP_NS
{
	class AbstractSession;

	%nodefaultctor ProtocolHandlers;
	class ProtocolHandlers
	{
	public:
		AbstractSession* getSession();
	};

	class CoreHandlers : public ProtocolHandlers
	{
	public:
		CoreHandlers(AbstractSession* mySession);
		virtual ~CoreHandlers();
		
		/**
		* @param msg			The ETP message body which has been received and which is to be processed.
		* @param correlationId	It is the correlation ID to use if a response is needed to this message. It corresponds to the message ID of the received ETP message.
		*/
	    virtual void on_RequestSession(const Energistics::Etp::v12::Protocol::Core::RequestSession& msg, int64_t correlationId);

		/**
		* @param msg			The ETP message body which has been received and which is to be processed.
		* @param correlationId	It is the correlation ID to use if a response is needed to this message. It corresponds to the message ID of the received ETP message.
		*/
	    virtual void on_OpenSession(const Energistics::Etp::v12::Protocol::Core::OpenSession& msg, int64_t correlationId);

		/**
		* @param msg			The ETP message body whic hhas been received and which is to be processed.
		* @param correlationId	It is the correlation ID to use if a response is needed to this message. It corresponds to the message ID of the received ETP message.
		*/
	    virtual void on_CloseSession(const Energistics::Etp::v12::Protocol::Core::CloseSession& msg, int64_t correlationId);

		/**
		* @param msg			The ETP message body which has been received and which is to be processed.
		* @param correlationId	It is the correlation ID (not message ID) of the received exception message.
		*/
	    virtual void on_ProtocolException(const Energistics::Etp::v12::Protocol::Core::ProtocolException& msg, int64_t correlationId);

		/**
		* @param msg			The ETP message body which has been received and which is to be processed.
		* @param correlationId	It is the correlation ID (not message ID) of the received ackknowledged message.
		*/
		virtual void on_Acknowledge(const Energistics::Etp::v12::Protocol::Core::Acknowledge& msg, int64_t correlationId);

		/**
		* @param msg			The ETP message body which has been received and which is to be processed.
		* @param correlationId	It is the correlation ID to use if a response is needed to this message. It corresponds to the message ID of the received ETP message.
		*/
		virtual void on_Ping(const Energistics::Etp::v12::Protocol::Core::Ping& msg, int64_t correlationId);
		
		/**
		* @param msg			The ETP message body which has been received and which is to be processed.
		* @param correlationId	It is the correlation ID to use if a response is needed to this message. It corresponds to the message ID of the received ETP message.
		*/
		virtual void on_Pong(const Energistics::Etp::v12::Protocol::Core::Pong& msg, int64_t correlationId);

		/**
		* @param msg			The ETP message body which has been received and which is to be processed.
		* @param correlationId	It is the correlation ID to use if a response is needed to this message. It corresponds to the message ID of the received ETP message.
		*/
		virtual void on_Authorize(const Energistics::Etp::v12::Protocol::Core::Authorize& msg, int64_t correlationId);

		/**
		* @param msg			The ETP message body which has been received and which is to be processed.
		* @param correlationId	It is the correlation ID to use if a response is needed to this message. It corresponds to the message ID of the received ETP message.
		*/
		virtual void on_AuthorizeResponse(const Energistics::Etp::v12::Protocol::Core::AuthorizeResponse& msg, int64_t correlationId);
	};
	
	class DiscoveryHandlers : public ProtocolHandlers
	{
	public:
		DiscoveryHandlers(AbstractSession* mySession);
		virtual ~DiscoveryHandlers();

		virtual void on_GetResources(const Energistics::Etp::v12::Protocol::Discovery::GetResources & msg, int64_t correlationId);
		virtual void on_GetResourcesResponse(const Energistics::Etp::v12::Protocol::Discovery::GetResourcesResponse & msg, int64_t correlationId);
	};
	
	class StoreHandlers : public ProtocolHandlers
	{
	public:
		StoreHandlers(AbstractSession* mySession);
		virtual ~StoreHandlers();

	    virtual void on_GetDataObjects(const Energistics::Etp::v12::Protocol::Store::GetDataObjects & msg, int64_t correlationId);
	    virtual void on_GetDataObjectsResponse(const Energistics::Etp::v12::Protocol::Store::GetDataObjectsResponse & msg, int64_t correlationId);
	    virtual void on_PutDataObjects(const Energistics::Etp::v12::Protocol::Store::PutDataObjects & msg, int64_t correlationId);
		virtual void on_PutDataObjectsResponse(const Energistics::Etp::v12::Protocol::Store::PutDataObjectsResponse & msg, int64_t correlationId);
	    virtual void on_DeleteDataObjects(const Energistics::Etp::v12::Protocol::Store::DeleteDataObjects & msg, int64_t correlationId);
		virtual void on_DeleteDataObjectsResponse(const Energistics::Etp::v12::Protocol::Store::DeleteDataObjectsResponse & msg, int64_t correlationId);
	};
	
	class StoreNotificationHandlers : public ProtocolHandlers
	{
	public:
		StoreNotificationHandlers(AbstractSession* mySession);
		virtual ~StoreNotificationHandlers();

	    virtual void on_SubscribeNotifications(const Energistics::Etp::v12::Protocol::StoreNotification::SubscribeNotifications & msg, int64_t messageId);
		virtual void on_SubscribeNotificationsResponse(const Energistics::Etp::v12::Protocol::StoreNotification::SubscribeNotificationsResponse & msg, int64_t messageId);
	    virtual void on_UnsubscribeNotifications(const Energistics::Etp::v12::Protocol::StoreNotification::UnsubscribeNotifications & msg, int64_t messageId, int64_t correlationId);
		virtual void on_UnsolicitedStoreNotifications(const Energistics::Etp::v12::Protocol::StoreNotification::UnsolicitedStoreNotifications & msg, int64_t correlationId);
		virtual void on_SubscriptionEnded(const Energistics::Etp::v12::Protocol::StoreNotification::SubscriptionEnded & msg, int64_t correlationId);
	    virtual void on_ObjectChanged(const Energistics::Etp::v12::Protocol::StoreNotification::ObjectChanged & msg, int64_t correlationId);
	    virtual void on_ObjectDeleted(const Energistics::Etp::v12::Protocol::StoreNotification::ObjectDeleted & msg, int64_t correlationId);
		virtual void on_ObjectAccessRevoked(const Energistics::Etp::v12::Protocol::StoreNotification::ObjectAccessRevoked & msg, int64_t correlationId);
		virtual void on_ObjectActiveStatusChanged(const Energistics::Etp::v12::Protocol::StoreNotification::ObjectActiveStatusChanged & msg, int64_t correlationId);
		virtual void on_Chunk(const Energistics::Etp::v12::Protocol::StoreNotification::Chunk & msg, int64_t correlationId);
	};
	
	class DataArrayHandlers : public ProtocolHandlers
	{
	public:
		DataArrayHandlers(AbstractSession* mySession);
		virtual ~DataArrayHandlers();

	    virtual void on_GetDataArrays(const Energistics::Etp::v12::Protocol::DataArray::GetDataArrays & gda, int64_t correlationId);
		virtual void on_GetDataArraysResponse(Energistics::Etp::v12::Protocol::DataArray::GetDataArraysResponse & gdar, int64_t correlationId);
	    virtual void on_PutDataArrays(const Energistics::Etp::v12::Protocol::DataArray::PutDataArrays & pda, int64_t correlationId);
		virtual void on_PutDataArraysResponse(const Energistics::Etp::v12::Protocol::DataArray::PutDataArraysResponse & msg, int64_t correlationId);
	    virtual void on_GetDataSubarrays(const Energistics::Etp::v12::Protocol::DataArray::GetDataSubarrays & msg, int64_t correlationId);
		virtual void on_GetDataSubarraysResponse(const Energistics::Etp::v12::Protocol::DataArray::GetDataSubarraysResponse & msg, int64_t correlationId);
	    virtual void on_PutDataSubarrays(const Energistics::Etp::v12::Protocol::DataArray::PutDataSubarrays & msg, int64_t correlationId);
		virtual void on_PutDataSubarraysResponse(const Energistics::Etp::v12::Protocol::DataArray::PutDataSubarraysResponse & msg, int64_t correlationId);
		virtual void on_GetDataArrayMetadata(const Energistics::Etp::v12::Protocol::DataArray::GetDataArrayMetadata & gdam, int64_t correlationId);
		virtual void on_GetDataArrayMetadataResponse(const Energistics::Etp::v12::Protocol::DataArray::GetDataArrayMetadataResponse & gdamr, int64_t correlationId);
		virtual void on_PutUninitializedDataArrays(const Energistics::Etp::v12::Protocol::DataArray::PutUninitializedDataArrays & msg, int64_t correlationId);
		virtual void on_PutUninitializedDataArraysResponse(const Energistics::Etp::v12::Protocol::DataArray::PutUninitializedDataArraysResponse & msg, int64_t correlationId);
	};
	
	class TransactionHandlers : public ProtocolHandlers
	{
	public:
		TransactionHandlers(AbstractSession* mySession);
		virtual ~TransactionHandlers();

	    virtual void on_StartTransaction(const Energistics::Etp::v12::Protocol::Transaction::StartTransaction & msg, int64_t correlationId);
		virtual void on_StartTransactionResponse(const Energistics::Etp::v12::Protocol::Transaction::StartTransactionResponse & msg, int64_t correlationId);
	    virtual void on_CommitTransaction(const Energistics::Etp::v12::Protocol::Transaction::CommitTransaction & msg, int64_t correlationId);
		virtual void on_CommitTransactionResponse(const Energistics::Etp::v12::Protocol::Transaction::CommitTransactionResponse & msg, int64_t correlationId);
	    virtual void on_RollbackTransaction(const Energistics::Etp::v12::Protocol::Transaction::RollbackTransaction & msg, int64_t correlationId);
		virtual void on_RollbackTransactionResponse(const Energistics::Etp::v12::Protocol::Transaction::RollbackTransactionResponse & msg, int64_t correlationId);
	};

	class DataspaceHandlers : public ProtocolHandlers
	{
	public:
		DataspaceHandlers(AbstractSession* mySession);
		virtual ~DataspaceHandlers();

	    virtual void on_GetDataspaces(const Energistics::Etp::v12::Protocol::Dataspace::GetDataspaces & msg, int64_t correlationId);
		virtual void on_GetDataspacesResponse(const Energistics::Etp::v12::Protocol::Dataspace::GetDataspacesResponse & msg, int64_t correlationId);
	    virtual void on_PutDataspaces(const Energistics::Etp::v12::Protocol::Dataspace::PutDataspaces & msg, int64_t correlationId);
		virtual void on_PutDataspacesResponse(const Energistics::Etp::v12::Protocol::Dataspace::PutDataspacesResponse & msg, int64_t correlationId);
	    virtual void on_DeleteDataspaces(const Energistics::Etp::v12::Protocol::Dataspace::DeleteDataspaces & msg, int64_t correlationId);
		virtual void on_DeleteDataspacesResponse(const Energistics::Etp::v12::Protocol::Dataspace::DeleteDataspacesResponse & msg, int64_t correlationId);
	};

	class DataspaceOSDUHandlers : public ProtocolHandlers
	{
	public:
		DataspaceOSDUHandlers(AbstractSession* mySession);
		virtual ~DataspaceOSDUHandlers();

		virtual void on_GetDataspaceInfo(const Energistics::Etp::v12::Protocol::DataspaceOSDU::GetDataspaceInfo& msg, int64_t correlationId);
		virtual void on_GetDataspaceInfoResponse(const Energistics::Etp::v12::Protocol::DataspaceOSDU::GetDataspaceInfoResponse& msg, int64_t correlationId);
	    virtual void on_CopyDataspacesContent(const Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyDataspacesContent& msg, int64_t correlationId);
		virtual void on_CopyDataspacesContentResponse(const Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyDataspacesContentResponse & msg, int64_t correlationId);
		virtual void on_LockDataspaces(const Energistics::Etp::v12::Protocol::DataspaceOSDU::LockDataspaces& msg, int64_t correlationId);
		virtual void on_LockDataspacesResponse(const Energistics::Etp::v12::Protocol::DataspaceOSDU::LockDataspacesResponse& msg, int64_t correlationId);
	    virtual void on_CopyToDataspace(const Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyToDataspace& msg, int64_t correlationId);
		virtual void on_CopyToDataspaceResponse(const Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyToDataspaceResponse & msg, int64_t correlationId);
	};

	%nodefaultctor AbstractSession;
	class AbstractSession
	{
	public:
		/**
		* Set the time out in milliseconds used when blocking waiting for message
		*/
		void setTimeOut(double timeOut);
	
		void setCoreProtocolHandlers(std::shared_ptr<ETP_NS::CoreHandlers> coreHandlers);
		void setDiscoveryProtocolHandlers(std::shared_ptr<DiscoveryHandlers> discoveryHandlers);
		void setStoreProtocolHandlers(std::shared_ptr<StoreHandlers> storeHandlers);
		void setStoreNotificationProtocolHandlers(std::shared_ptr<ETP_NS::StoreNotificationHandlers> storeNotificationHandlers);
		void setDataArrayProtocolHandlers(std::shared_ptr<DataArrayHandlers> dataArrayHandlers);
		void setTransactionProtocolHandlers(std::shared_ptr<TransactionHandlers> transactionHandlers);
		void setDataspaceProtocolHandlers(std::shared_ptr<DataspaceHandlers> dataspaceHandlers);
		void setDataspaceOSDUProtocolHandlers(std::shared_ptr<DataspaceOSDUHandlers> dataspaceOSDUHandlers);

		template<typename T> int64_t sendWithSpecificHandler(const T & mb, std::shared_ptr<ETP_NS::ProtocolHandlers> specificHandler, int64_t correlationId = 0, int32_t messageFlags = 0)
		{
			int64_t msgId = encode(mb, correlationId, messageFlags); // put the message to write in the queue

			if (sendingQueue.size() == 1) {
				do_write();
			}
			specificProtocolHandlers[msgId] = specificHandler;

			return msgId;
		}		
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Core::RequestSession>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Core::OpenSession>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Core::CloseSession>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Core::ProtocolException>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Core::Acknowledge>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Core::Ping>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Core::Pong>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Core::Authorize>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Core::AuthorizeResponse>;
		
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Discovery::GetResources>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Discovery::GetResourcesResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Discovery::GetResourcesEdgesResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Discovery::GetDeletedResources>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Discovery::GetDeletedResourcesResponse>;
		
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Store::GetDataObjects>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Store::GetDataObjectsResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Store::PutDataObjects>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Store::PutDataObjectsResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Store::DeleteDataObjects>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Store::DeleteDataObjectsResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Store::Chunk>;
		
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataArray::GetDataArrays>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataArray::GetDataArraysResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataArray::PutDataArrays>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataArray::PutDataArraysResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataArray::GetDataSubarrays>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataArray::GetDataSubarraysResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataArray::PutDataSubarrays>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataArray::PutDataSubarraysResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataArray::GetDataArrayMetadata>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataArray::GetDataArrayMetadataResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataArray::PutUninitializedDataArrays>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataArray::PutUninitializedDataArraysResponse>;
		
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Transaction::StartTransaction>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Transaction::StartTransactionResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Transaction::CommitTransaction>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Transaction::CommitTransactionResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Transaction::RollbackTransaction>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Transaction::RollbackTransactionResponse>;
		
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Dataspace::GetDataspaces>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Dataspace::GetDataspacesResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Dataspace::PutDataspaces>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Dataspace::PutDataspacesResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Dataspace::DeleteDataspaces>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::Dataspace::DeleteDataspacesResponse>;
		
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataspaceOSDU::GetDataspaceInfo>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataspaceOSDU::GetDataspaceInfoResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyDataspacesContent>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyDataspacesContentResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataspaceOSDU::LockDataspaces>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataspaceOSDU::LockDataspacesResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyToDataspace>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyToDataspaceResponse>;
		
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::StoreNotification::SubscribeNotificationsResponse>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::StoreNotification::Chunk>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::StoreNotification::ObjectAccessRevoked>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::StoreNotification::ObjectDeleted>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::StoreNotification::SubscriptionEnded>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::StoreNotification::UnsubscribeNotifications>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::StoreNotification::ObjectActiveStatusChanged>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::StoreNotification::ObjectChanged>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::StoreNotification::SubscribeNotifications>;
		%template(sendWithSpecificHandler) sendWithSpecificHandler<Energistics::Etp::v12::Protocol::StoreNotification::UnsolicitedStoreNotifications>;
		
		template<typename T> int64_t send(const T & mb, int64_t correlationId = 0, int32_t messageFlags = 0)
		{
			if (protocolHandlers.size() > mb.protocolId) {
				return sendWithSpecificHandler(mb, protocolHandlers[mb.protocolId], correlationId, messageFlags);
			}
			else {
				throw std::logic_error("The agent has no registered handler at all for the protocol " + std::to_string(mb.protocolId));
			}
		}
		%template(send) send<Energistics::Etp::v12::Protocol::Core::RequestSession>;
		%template(send) send<Energistics::Etp::v12::Protocol::Core::OpenSession>;
		%template(send) send<Energistics::Etp::v12::Protocol::Core::CloseSession>;
		%template(send) send<Energistics::Etp::v12::Protocol::Core::ProtocolException>;
		%template(send) send<Energistics::Etp::v12::Protocol::Core::Acknowledge>;
		%template(send) send<Energistics::Etp::v12::Protocol::Core::Ping>;
		%template(send) send<Energistics::Etp::v12::Protocol::Core::Pong>;
		%template(send) send<Energistics::Etp::v12::Protocol::Core::Authorize>;
		%template(send) send<Energistics::Etp::v12::Protocol::Core::AuthorizeResponse>;
		
		%template(send) send<Energistics::Etp::v12::Protocol::Discovery::GetResources>;
		%template(send) send<Energistics::Etp::v12::Protocol::Discovery::GetResourcesResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::Discovery::GetResourcesEdgesResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::Discovery::GetDeletedResources>;
		%template(send) send<Energistics::Etp::v12::Protocol::Discovery::GetDeletedResourcesResponse>;
		
		%template(send) send<Energistics::Etp::v12::Protocol::Store::GetDataObjects>;
		%template(send) send<Energistics::Etp::v12::Protocol::Store::GetDataObjectsResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::Store::PutDataObjects>;
		%template(send) send<Energistics::Etp::v12::Protocol::Store::PutDataObjectsResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::Store::DeleteDataObjects>;
		%template(send) send<Energistics::Etp::v12::Protocol::Store::DeleteDataObjectsResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::Store::Chunk>;
		
		%template(send) send<Energistics::Etp::v12::Protocol::DataArray::GetDataArrays>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataArray::GetDataArraysResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataArray::PutDataArrays>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataArray::PutDataArraysResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataArray::GetDataSubarrays>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataArray::GetDataSubarraysResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataArray::PutDataSubarrays>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataArray::PutDataSubarraysResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataArray::GetDataArrayMetadata>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataArray::GetDataArrayMetadataResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataArray::PutUninitializedDataArrays>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataArray::PutUninitializedDataArraysResponse>;
		
		%template(send) send<Energistics::Etp::v12::Protocol::Transaction::StartTransaction>;
		%template(send) send<Energistics::Etp::v12::Protocol::Transaction::StartTransactionResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::Transaction::CommitTransaction>;
		%template(send) send<Energistics::Etp::v12::Protocol::Transaction::CommitTransactionResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::Transaction::RollbackTransaction>;
		%template(send) send<Energistics::Etp::v12::Protocol::Transaction::RollbackTransactionResponse>;
		
		%template(send) send<Energistics::Etp::v12::Protocol::Dataspace::GetDataspaces>;
		%template(send) send<Energistics::Etp::v12::Protocol::Dataspace::GetDataspacesResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::Dataspace::PutDataspaces>;
		%template(send) send<Energistics::Etp::v12::Protocol::Dataspace::PutDataspacesResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::Dataspace::DeleteDataspaces>;
		%template(send) send<Energistics::Etp::v12::Protocol::Dataspace::DeleteDataspacesResponse>;
		
		%template(send) send<Energistics::Etp::v12::Protocol::DataspaceOSDU::GetDataspaceInfo>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataspaceOSDU::GetDataspaceInfoResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyDataspacesContent>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyDataspacesContentResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataspaceOSDU::LockDataspaces>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataspaceOSDU::LockDataspacesResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyToDataspace>;
		%template(send) send<Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyToDataspaceResponse>;
		
		%template(send) send<Energistics::Etp::v12::Protocol::StoreNotification::SubscribeNotificationsResponse>;
		%template(send) send<Energistics::Etp::v12::Protocol::StoreNotification::Chunk>;
		%template(send) send<Energistics::Etp::v12::Protocol::StoreNotification::ObjectAccessRevoked>;
		%template(send) send<Energistics::Etp::v12::Protocol::StoreNotification::ObjectDeleted>;
		%template(send) send<Energistics::Etp::v12::Protocol::StoreNotification::SubscriptionEnded>;
		%template(send) send<Energistics::Etp::v12::Protocol::StoreNotification::UnsubscribeNotifications>;
		%template(send) send<Energistics::Etp::v12::Protocol::StoreNotification::ObjectActiveStatusChanged>;
		%template(send) send<Energistics::Etp::v12::Protocol::StoreNotification::ObjectChanged>;
		%template(send) send<Energistics::Etp::v12::Protocol::StoreNotification::SubscribeNotifications>;
		%template(send) send<Energistics::Etp::v12::Protocol::StoreNotification::UnsolicitedStoreNotifications>;
		
		template<typename T> void sendAndBlock(const T & mb, int64_t correlationId = 0, int32_t messageFlags = 0)
		{
			int64_t msgId = send(mb, correlationId, messageFlags);
			while (isMessageStillProcessing(msgId)) {}
		}
		
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Core::RequestSession>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Core::OpenSession>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Core::CloseSession>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Core::ProtocolException>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Core::Acknowledge>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Core::Ping>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Core::Pong>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Core::Authorize>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Core::AuthorizeResponse>;
		
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Discovery::GetResources>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Discovery::GetResourcesResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Discovery::GetResourcesEdgesResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Discovery::GetDeletedResources>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Discovery::GetDeletedResourcesResponse>;
		
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Store::GetDataObjects>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Store::GetDataObjectsResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Store::PutDataObjects>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Store::PutDataObjectsResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Store::DeleteDataObjects>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Store::DeleteDataObjectsResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Store::Chunk>;
		
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataArray::GetDataArrays>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataArray::GetDataArraysResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataArray::PutDataArrays>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataArray::PutDataArraysResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataArray::GetDataSubarrays>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataArray::GetDataSubarraysResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataArray::PutDataSubarrays>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataArray::PutDataSubarraysResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataArray::GetDataArrayMetadata>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataArray::GetDataArrayMetadataResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataArray::PutUninitializedDataArrays>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataArray::PutUninitializedDataArraysResponse>;
		
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Transaction::StartTransaction>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Transaction::StartTransactionResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Transaction::CommitTransaction>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Transaction::CommitTransactionResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Transaction::RollbackTransaction>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Transaction::RollbackTransactionResponse>;
		
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Dataspace::GetDataspaces>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Dataspace::GetDataspacesResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Dataspace::PutDataspaces>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Dataspace::PutDataspacesResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Dataspace::DeleteDataspaces>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::Dataspace::DeleteDataspacesResponse>;
		
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataspaceOSDU::GetDataspaceInfo>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataspaceOSDU::GetDataspaceInfoResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyDataspacesContent>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyDataspacesContentResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataspaceOSDU::LockDataspaces>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataspaceOSDU::LockDataspacesResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyToDataspace>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::DataspaceOSDU::CopyToDataspaceResponse>;
		
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::StoreNotification::SubscribeNotificationsResponse>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::StoreNotification::Chunk>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::StoreNotification::ObjectAccessRevoked>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::StoreNotification::ObjectDeleted>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::StoreNotification::SubscriptionEnded>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::StoreNotification::UnsubscribeNotifications>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::StoreNotification::ObjectActiveStatusChanged>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::StoreNotification::ObjectChanged>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::StoreNotification::SubscribeNotifications>;
		%template(sendAndBlock) sendAndBlock<Energistics::Etp::v12::Protocol::StoreNotification::UnsolicitedStoreNotifications>;
		
		/**
		* Check wether a particular ETP message has been responded or not by the other agent.
		*/
		bool isMessageStillProcessing(int64_t msgId);
		
		/****************
		***** CORE ******
		****************/
		
		/**
		* Send a message for closing to the server after having sent all previous messages.
		* The session would really close only after all messages have been sent and responded.
		* This method does not block.
		*/
		void close();

		/**
		* Send a message for closing to the server after having sent all previous messages.
		* The session would really close only after all messages have been sent and responded.
		* This method does block.
		*/
		void closeAndBlock();
		
		/**
		* Check if the ETP session (starting after the Core.OpenSession or Core.RequestSession message) is not opened yet or has been closed.
		*/
		bool isEtpSessionClosed() const;

		/****************
		*** DATASPACE ***
		****************/

		/**
		* A customer sends to a store to discover all dataspaces available on the store.
		* This function should be used with caution if Dataspace Handlers have been overidden.
		* It actually sends a message and block the current thread untill a response has been received from the store.
		*
		* @param storeLastWriteFilter	An optional filter to limit the dataspaces returned by date/time last saved to the store.
		*								The store returns a list of dataspaces whose last changed date/time is greater than the specified date/time.
		*								It must be a UTC dateTime value, serialized as a positive long, using the Avro logical type timestamp-micros (microseconds from the Unix Epoch, 1 January 1970 00:00:00.000000 UTC).
		* @param return	The available dataspaces the store could return.
		*/
		std::vector<Energistics::Etp::v12::Datatypes::Object::Dataspace> getDataspaces(int64_t storeLastWriteFilter = -1);

		/**
		* A customer sends to a store to create one or more dataspaces.
		* This function should be used with caution if Dataspace Handlers have been overidden.
		* It actually sends a message and block the current thread untill a response has been received from the store.
		*
		* @param dataspaces  ETP general map : One each for each dataspace the customer wants to add or update.
		* @param return	The map keys corresponding to the dataspaces which have been put successfully into the store.
		*/
		std::vector<std::string> putDataspaces(const std::map<std::string, Energistics::Etp::v12::Datatypes::Object::Dataspace>& dataspaces);

		/**
		* A customer sends to a store to delete one or more dataspaces.
		* This function should be used with caution if Dataspace Handlers have been overidden.
		* It actually sends a message and block the current thread untill a response has been received from the store.
		*
		* @param dataspaceUris  ETP general map where the values must be the URIs for the dataspaces the customer wants to delete.
		* @param return	The map keys corresponding to the dataspaces which have been deleted successfully.
		*/
		std::vector<std::string> deleteDataspaces(const std::map<std::string, std::string>& dataspaceUris);

		/*********************
		*** DATASPACE OSDU ***
		**********************/

		/**
		* A customer sends to a store to discover information of particular dataspaces.
		* This function should be used with caution if Dataspace OSDU Handlers have been overidden.
		* It actually sends a message and block the current thread untill a response has been received from the store.
		*
		* @param dataspaceUris	ETP general map : One each for each dataspace, identified by their URI, the customer wants to get info about.
		* @param return	The dataspaces the store could return.
		*/
		std::vector<Energistics::Etp::v12::Datatypes::Object::Dataspace> getDataspaceInfo(const std::map<std::string, std::string>& dataspaceUris);

		/**
		* Copy by reference some dataspaces into another one.
		* This function should be used with caution if Dataspace OSDU Handlers have been overidden.
		* It actually sends a message and block the current thread untill a response has been received from the store.
		*
		* @param sourceDataspaceUris  ETP general map : One each for each source dataspace to be copied. They are identified by their URI.
		* @param targetDataspaceUri  The URI of the ETP dataspace where the sourceDataspaces have to be copied by reference.
		* @param return	The map keys corresponding to the dataspaces which have been successfully copied into the target dataspace.
		*/
		std::vector<std::string> copyDataspacesContent(const std::map<std::string, std::string>& sourceDataspaceUris, const std::string& targetDataspaceUri);

		/**
		* A customer sends to a store to lock or unlock one or more dataspaces.
		* This function should be used with caution if Dataspace OSDU Handlers have been overidden.
		* It actually sends a message and block the current thread untill a response has been received from the store.
		*
		* @param dataspaceUris  ETP general map where the values must be the URIs for the dataspaces the customer wants to lock or unlock.
		* @param lock true for locking the dataspaces, false to unlock the dataspaces
		* @param return	The map keys corresponding to the dataspaces which have been successfully locked or unlocked.
		*/
		std::vector<std::string> lockDataspaces(const std::map<std::string, std::string>& dataspaceUris, bool lock);

		/**
		* Copy by reference some dataobjects into another dataspace.
		* This function should be used with caution if Dataspace OSDU Handlers have been overidden.
		* It actually sends a message and block the current thread untill a response has been received from the store.
		*
		* @param sourceUris  ETP general map : One each for each source dataobject to be copied. They are identified by their URI.
		* @param targetDataspaceUri  The URI of the ETP dataspace where the source dataobjects have to be copied by reference.
		* @param return	The map keys corresponding to the dataobjects which have been successfully copied into the target dataspace.
		*/
		std::vector<std::string> copyToDataspace(const std::map<std::string, std::string>& sourceUris, const std::string& targetDataspaceUri);

		/****************
		*** DISCOVERY ***
		****************/

		/**
		* A Customer sends this message to a store to discover data objects in the store.
		* This function should be used with caution if Discovery Handlers have been overidden.
		* It actually sends a message and block the current thread untill a response has been received from the store.
		*
		* @param context				Includes the URI of the dataspace or data object to begin the discovery, what specific types of data objects are of interest,
		*								and how many "levels" of relationships in the model to discover, among others. 
		* @param scope					Scope is specified in reference to the URI (which is entered in the context field).
		*								It indicates which direction in the graph that the operation should proceed (targets or sources) and whether or not to include the starting point (self).
		* @param storeLastWriteFilter	An optional filter to filter the discovery on a date when the data object was last written in a particular store.
		*								The store returns resources whose storeLastWrite date/time is GREATER than the date/time specified in this filter field.
		*								It must be a UTC dateTime value, serialized as a positive long, using the Avro logical type timestamp-micros (microseconds from the Unix Epoch, 1 January 1970 00:00:00.000000 UTC).
		* @param countObjects			If true, the store provides counts of sources and targets for each resource identified by Discovery.
		* @param return					The resources corresponding to this query.
		*/
		std::vector<Energistics::Etp::v12::Datatypes::Object::Resource> getResources(
			const Energistics::Etp::v12::Datatypes::Object::ContextInfo& context,
			const Energistics::Etp::v12::Datatypes::Object::ContextScopeKind& scope,
			int64_t storeLastWriteFilter = -1,
			bool countObjects = false);

		/**
		* A customer sends to a store to discover data objects that have been deleted (which are sometimes called "tombstones").
		* This function should be used with caution if Discovery Handlers have been overidden.
		* It actually sends a message and block the current thread untill a response has been received from the store.
		*
		* @param dataspaceUri			The URI of the dataspace where the objects were deleted.
		* @param deleteTimeFilter		An optional filter to filter the discovery on a date when the data object was deleted in a particular store.
		*								The store returns resources for objects whose delete times are greater than this value.
		*								It must be a UTC dateTime value, serialized as a positive long, using the Avro logical type timestamp-micros (microseconds from the Unix Epoch, 1 January 1970 00:00:00.000000 UTC).
		* @param dataObjectTypes		Filter for the types of data objects you want. EXAMPLES: "witsml20.Well", "resqml20.obj_TectonicBoundaryFeature", "resqml20.*" 
		* @param return					The deleted resources corresponding to this query.
		*/
		std::vector<Energistics::Etp::v12::Datatypes::Object::DeletedResource> getDeletedResources(
			const std::string& dataspaceUri,
			int64_t deleteTimeFilter = -1,
			const std::vector<std::string>& dataObjectTypes = {});

		/****************
		***** STORE *****
		****************/

		/**
		* A customer sends to a store to get one or more data objects, each identified by a URI.
		* This function should be used with caution if Store Handlers have been overidden.
		* It actually sends a message and block the current thread untill a response has been received from the store.
		*
		* @param uris	ETP general map where the values MUST be the URIs of a data object to be retrieved.
		* @param return	The received dataobjects in a map where the key makes the link between the asked uris and the received dataobjects.
		*/
		std::map<std::string, Energistics::Etp::v12::Datatypes::Object::DataObject> getDataObjects(const std::map<std::string, std::string>& uris);

		/**
		* A customer sends to a store to add or update one or more data objects.
		* This function should be used with caution if Store Handlers have been overidden.
		* It actually sends a message and block the current thread untill a response has been received from the store.
		*
		* @param uris	ETP general map where the values MUST be the data for each data object in the request, including each one's URI.
		* @param return	The map keys corresponding to the dataObjects which have been put successfully.
		*/
		std::vector<std::string> putDataObjects(const std::map<std::string, Energistics::Etp::v12::Datatypes::Object::DataObject>& dataObjects);

		/**
		* A customer sends to a store to delete one or more data objects from the store.  
		* This function should be used with caution if Store Handlers have been overidden.
		* It actually sends a message and block the current thread untill a response has been received from the store.
		*
		* @param uris	ETP general map where the values MUST be the URIs of a data object to be deleted.
		* @param return	The map keys corresponding to the dataObjects which have been deleted successfully.
		*/
		std::vector<std::string> deleteDataObjects(const std::map<std::string, std::string>& uris);

		/****************
		** TRANSACTION **
		****************/

		/**
		* A customer sends to a store to begin a transaction.
		* This function should be used with caution if Transaction Handlers have been overidden.
		* It actually sends a message and block the current thread untill a response has been received from the store.
		*
		* @param dataspaceUris  Indicates the dataspaces involved in the transaction. An empty STRING means the default dataspace. An empty LIST means all dataspaces.
		* @param readOnly		Indicates that the request in the transaction is read-only (i.e., "get" messages). 
		*/
		std::string startTransaction(std::vector<std::string> dataspaceUris = {}, bool readOnly = false);

		/**
		* A customer sends to a store to commit and end a transaction. This message implies that the customer 
		* has received from or sent to the store all the data required for some purpose. The customer asserts that 
		* the data sent in the scope of this transaction is a consistent unit of work.
		* It actually sends a message and block the current thread untill a response has been received from the store.
		*/
		std::string rollbackTransaction();

		/*
		* A customer sends to a store to cancel a transaction. The store MUST disregard any requests or data sent 
		* with that transaction. The current transaction (the one being canceled) MUST NOT change the state of 
		* the store.
		* It actually sends a message and block the current thread untill a response has been received from the store.
		*/
		std::string commitTransaction();
		
		/**
		* Indicates if the session must be verbose or not
		*/
		void setVerbose(bool verbose);
	};

	namespace EtpHelpers {
		/**
		* Get the dataobject type from a canonical ETP 1.2 URI.
		*
		* @param uri	The input canonical ETP 1.2 URI
		* @return		The URI dataobject type or the empty string if the operation cannot succeed
		*/
		std::string getDataObjectType(const std::string& uri);

		/**
		* Get the dataspace URI from a canonical ETP 1.2 URI.
		*
		* @param uri	The input canonical ETP 1.2 URI
		* @return		The dataspace URI or the empty string if the operation cannot succeed
		*/
		std::string getDataspaceUri(const std::string& uri);

		/**
		* @param session Provide this parameter if you want to send a protocol exception in case of non validation.
		*/
		Energistics::Etp::v12::Datatypes::ErrorInfo validateUri(const std::string & uri, ETP_NS::AbstractSession* session = nullptr);

		/**
		* @param session Provide this parameter if you want to send a protocol exception in case of non validation.
		*/
		Energistics::Etp::v12::Datatypes::ErrorInfo validateDataObjectUri(const std::string & uri, ETP_NS::AbstractSession* session = nullptr);

		/**
		* Build a protocol exception message which only contains a single error message (not a messsage map).
		*/
		Energistics::Etp::v12::Protocol::Core::ProtocolException buildSingleMessageProtocolException(int32_t m_code, const std::string & m_message);
	}

	/******************* CLIENT ***************************/

	%nodefaultctor ClientSession;
	class ClientSession : public AbstractSession
	{
	public:
		/**
		* Run the websocket and then the ETP session.
		* Everything related to this session (including the completion handlers) will operate on the same unique thread in a single event loop.
		*/
		bool run();
	};

	class InitializationParameters
	{
	public:
		/**
		* @param instanceUuid	The UUID of the client instance.
		* @param etpServerUrl	Must follow the syntax ws://<host>:<port>/<path> or wss://<host>:<port>/<path> or simply <host>:<port>/<path>
		*						where port is optional and is defaulted to 80 if scheme is "ws" or if no scheme is provided.
		*						In "wss" schema cases, port is defaulted to 443.
		* @param proxyUrl		The proxy URL. It must follow the syntax http://<host>:<port> or simply <host>:<port>.
		*						Leave it empty if your connection to eptServerUrl is direct and does not pass throughr any proxy.
		*/
		InitializationParameters(const std::string& instanceUuid,
			const std::string& etpServerUrl, const std::string& proxyUrl = "");
		InitializationParameters(const std::string& instanceUuid, const std::string & host, unsigned short port, const std::string & urlPath = "");
		virtual ~InitializationParameters();

		void setMaxWebSocketMessagePayloadSize(int64_t value);
		uint64_t getMaxWebSocketMessagePayloadSize() const;

		void setPreferredMaxFrameSize(uint64_t value);
		uint64_t getPreferredMaxFrameSize() const;

		void setAdditionalHandshakeHeaderFields(const std::map<std::string, std::string>& extraHandshakeHeaderFields);
		const std::map<std::string, std::string>& getAdditionalHandshakeHeaderFields() const;

		void setAdditionalCertificates(const std::string& extraCertificates);
		const std::string& getAdditionalCertificates() const;

		const std::string& getEtpServerHost() const;
		uint16_t getEtpServerPort() const;
		const std::string& getEtpServerUrlPath() const;

		const std::string& getProxyHost() const;
		uint16_t getProxyPort() const;

		void setForceTls(bool force);
		bool isTlsForced() const;

		virtual std::string getApplicationName() const;
		virtual std::string getApplicationVersion() const;

		virtual std::vector<Energistics::Etp::v12::Datatypes::SupportedDataObject> makeSupportedDataObjects() const;
		virtual std::vector<Energistics::Etp::v12::Datatypes::SupportedProtocol> makeSupportedProtocols() const;

		/**
		* Override this method in order to register some dedicated protocol handlers for a session.
		*/
		virtual void postSessionCreationOperation(AbstractSession* session) const;
	};

	namespace ClientSessionLaunchers
	{
		/**
		* Create a client session based on some initialization parameters and authorization information.
		* It does not run the created client session.
		* @param initializationParams	The initialization parameters
		* @param etpServerAuthorization The etp server authorization. It generally starts by "Bearer" followed by a token i.e. "Bearer myToken"
		* @param proxyAuthorization		The proxy authorization. Necessary if the session connects to the ETP server through a protected proxy.
		*/
		std::shared_ptr<ETP_NS::ClientSession> createClientSession(InitializationParameters const* initializationParams,
			const std::string& etpServerAuthorization, const std::string& proxyAuthorization = "");
	}
	
#ifdef WITH_FESAPI
%typemap(javaimports) FesapiHdfProxyFactory %{
	import com.f2i_consulting.fesapi.common.HdfProxyFactory;
%}
%typemap(csimports) FesapiHdfProxyFactory %{
	using F2iConsulting.Fesapi.common;
%}	
	class FesapiHdfProxyFactory : public COMMON_NS::HdfProxyFactory
	{
	public:
		FesapiHdfProxyFactory(AbstractSession* session); // We may have to tell PlainClientSession instead of AbstractSession for some directors/inheritancy reason.
	};
	
	namespace FesapiHelpers {
		/**
		* Build and return an ETP resource from an Energistics object.
		* @param obj		The input Energistics obj
		* @param countRels	Indicate if the returned resource contain the count of source or target relationships.
		* @return			The ETP resource built from the Energistics object
		*/
		Energistics::Etp::v12::Datatypes::Object::Resource buildEtpResourceFromEnergisticsObject(COMMON_NS::AbstractObject const* obj, bool countRels = true);

		/**
		* Build and return an ETP data object from an Energistics object.
		* @param obj	The input Energistics obj
		* @return		The ETP data object built from the Energistics object
		*/
		Energistics::Etp::v12::Datatypes::Object::DataObject buildEtpDataObjectFromEnergisticsObject(COMMON_NS::AbstractObject * obj, bool includeSerialization = true);
	}
#endif
}

#ifdef WITH_FESAPI
%pragma(java) moduleimports="import com.f2i_consulting.fesapi.common.AbstractObject;"
%pragma(java) jniclassimports="import com.f2i_consulting.fesapi.common.AbstractObject;"
%pragma(csharp) moduleimports="using F2iConsulting.Fesapi.common;"
#endif